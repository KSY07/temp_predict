export enum SeverityLevel {
    CATASTROPHIC = 10, // 다수 사망/중상
    CRITICAL = 8, // 사망 또는 중상 가능
    MARGINAL = 6, // 경상 또는 중대한 시스템 손상
    MINOR = 3, // 경미한 부상 또는 시스템 손상
    NEGLIGIBLE = 1 // 무시할 수 있는 영향
}

export enum OccurrenceLevel {
    VERY_HIGH = 10, // 1/10 이상
    HIGH = 8, // 1/100
    MDERATE = 6, // 1/1000
    LOW = 4, // 1/10000
    VERY_LOW = 2, // 1/100000
    EXTREMELY_LOW = 1 // 1/1000000 미만
}

export enum DetectionLevel {
    ALMOST_IMPOSSIBLE = 10, // 검출 거의 불가능
    VERY_LOW = 8, // 매우 낮은 검출 가능성
    LOW = 6, // 낮은 검출 가능성
    MODERATE = 4, // 중간 검출 가능성
    HIGH = 2, // 높은 검출 가능성
    ALMOST_CERTAIN = 1 // 거의 확실한 검출
}

export enum FailureModeType {
    COMPLETE_FAILURE = 'COMPLETE_FAILURE',
    PARTIAL_FAILURE = 'PARTIAL_FAILURE',
    INTERMITTENT_FAILURE = 'INTERMITTENT_FAILURE',
    DEGRADED_PERFORMANCE = 'DEGRADED_PERFORMANCE',
    PERMATURE_OPERATION = 'PERMATURE_OPERATION',
    FAILURE_TO_OPERATE = 'FAILURE_TO_OPERATE',
    FALSE_OPERATION = 'FALSE_OPERATION'
}

export enum EffectLevel {
    LOCAL = 'LOCAL', // 부품 레벨
    NEXT_HIGHET = 'NEXT_HIGHER', // 다음 상위 레벨
    SUBSYSTEM = 'SUBSYSTEM', // 서브 시스템 레벨
    SYSTEM = 'SYSTEM', // 시스템 레벨
    TRAIN = 'TRAIN', // 열차 전체
    OPERATION = 'OPERATION' // 운영/승객
}

export interface IFMECA { // FMECA 통합 Interface
    id: string;
    componentId: string;
    failureMode: IFailureMode;
    effects: IEffect[];
    causes: ICause[];
    currentControls: IControl[];
    severity: SeverityLevel;
    occurrence: OccurrenceLevel;
    detection: DetectionLevel;
    rpn: number; // Risk Priority Number (위험도 우선도)
    recommendedActions: IRecommendedAction[];
    residualRisk?: IResidualRisk;
}

export interface IFailureMode { // 고장 유형 Interface
    type: FailureModeType;
    description: string;
    failureRate?: number;
    mtbf?:number;
}

export interface IEffect { // 고장 영향 Interface
    level: EffectLevel;
    description: string;
    impactOnSafety: boolean;
    impactOnOperation: boolean;
    downtime?: number;
}

export interface ICause { // 고장 원인 Interface
    description: string;
    category: CauseCategory;
    rootCause?: string;
}

export enum CauseCategory { // 원인 분류
    DESIGN = 'DESIGN',
    MANUFACTURING = 'MANUFACTURING',
    MATERIAL = 'MATERIAL',
    WEAR = 'WEAR',
    MAINTENANCE = 'MAINTENANCE',
    OPERATION = 'OPERATION',
    ENVIRONMENT = 'ENVIRONMENT',
    EXTERNAL = 'EXTERNAL'
}

export interface IControl { // 고장 검지 방법
    type: ControlType;
    description: string;
    effectiveness: ControlEffectiveness;
}

export enum ControlType {
    PREVENTION = 'PREVENTION',
    DETECTION = 'DETECTION',
    MITIGATION = 'MITIGATION'
}

export enum ControlEffectiveness {
    HIGH = 'HIGH',
    MEDIUM = 'MEDIUM',
    LOW = 'LOW'
}

export interface IRecommendedAction { // 권고 조치 사항
    description: string;
    type: ActionType;
    priority: ActionPriority;
    responsibleParty: string;
    targetDate?: Date;
    status: ActionStatus;
}

export enum ActionType { // 조치 방법
    DESIGN_CHANGE = 'DESIGN_CHANGE',
    PROCESS_CHANGE = 'PROCESS_CHANGE',
    ISNPECTION = 'INSPECTION',
    MAINTENANCE = 'MAINTENANCE',
    TRAINING = 'TRAINING',
    REDUNDANCY = 'REDUNDANCY'
}

export enum ActionPriority { // 조치 우선 순위
    IMEEDIATE = 'IMMEDIATE',
    HIGH = 'HIGH',
    MEDIUM = 'MEDIUM',
    LOW = 'LOW'
}

export enum ActionStatus { // 조치 상태
    PROPOSED = 'PROPOSED',
    APPROVED = 'APPROVED',
    IN_PROGRESS = 'IN_PROGRESS',
    COMPLETED = 'COMPLETED',
    VERIFIED = 'VERIFIED'
}

export interface IResidualRisk {
    severity: SeverityLevel;
    occurrence: OccurrenceLevel;
    detection: DetectionLevel;
    rpn: number;
}

export enum EnvironmentalCondition {
    HIGH_TEMPERATURE = 'HIGH_TEMPERATURE',
    LOW_TEMPERATURE = 'LOW_TEMPERATURE',
    HIGH_HUMIDITY = 'HIGH_HUMIDITY',
    RAIN = 'RAIN',
    SNOW = 'SNOW',
    DUST = 'DUST',
    VIBRATION = 'VIBRATION',
    EMI = 'EMI' // Electromagnetic Interference
}

export enum MaintenanceStrategy {
    CORRECTIVE = 'CORRECTIVE',
    PREVENTIVE = 'PREVENTIVE',
    PREDICTIVE = 'PREDICTIVE',
    CONDITION_BASED = 'CONDITION_BASED'
}

// Implementation FMECA
export class FMECA implements IFMECA {
      id: string;
      componentId: string;
      failureMode: IFailureMode;
      effects: IEffect[];
      causes: ICause[];
      currentControls: IControl[];
      severity: SeverityLevel;
      occurrence: OccurrenceLevel;
      detection: DetectionLevel;
      rpn: number;
      recommendedActions: IRecommendedAction[];
      residualRisk?: IResidualRisk;

      constructor(data: Omit<IFMECA, 'rpn'>) {
          this.id = data.id;
          this.componentId = data.componentId;
          this.failureMode = data.failureMode;
          this.effects = data.effects;
          this.causes = data.causes;
          this.currentControls = data.currentControls;
          this.severity = data.severity;
          this.occurrence = data.occurrence;
          this.detection = data.detection;
          this.recommendedActions = data.recommendedActions;
          this.residualRisk = data.residualRisk;
          this.rpn = this.calculateRPN();
      }

      calculateRPN(): number {
          return this.severity * this.occurrence * this.detection;
      }

      updateRatings(severity?: SeverityLevel, occurrence?: OccurrenceLevel, detection?: DetectionLevel): void {
          if (severity !== undefined) this.severity = severity;
          if (occurrence !== undefined) this.occurrence = occurrence;
          if (detection !== undefined) this.detection = detection;
          this.rpn = this.calculateRPN();
      }

      calculateResidualRisk(): void {
          // 추천 조치가 완료된 경우 잔존 위험도 계산
          const completedActions = this.recommendedActions.filter(
              action => action.status === ActionStatus.COMPLETED ||
                       action.status === ActionStatus.VERIFIED
          );

          if (completedActions.length > 0) {
              // 간단한 예: 각 완료된 조치가 RPN을 10% 감소시킨다고 가정
              const reductionFactor = Math.pow(0.9, completedActions.length);
              const newRPN = Math.round(this.rpn * reductionFactor);

              this.residualRisk = {
                  severity: this.severity,
                  occurrence: Math.max(1, Math.round(this.occurrence * reductionFactor)),
                  detection: Math.max(1, Math.round(this.detection * reductionFactor)),
                  rpn: newRPN
              };
          }
      }

      getCriticalityLevel(): string {
          if (this.rpn >= 200) return 'CRITICAL';
          if (this.rpn >= 100) return 'HIGH';
          if (this.rpn >= 50) return 'MEDIUM';
          return 'LOW';
      }
  }